#!/usr/bin/env python
import enum
import sys
import os
import threading
import csv
import math
import numpy
import time
from random import random, randint
import datetime

import rospy
from base.base_runner import TestBase
from geometry_msgs.msg import PoseStamped
from std_msgs.msg import Float64
from araig_msgs.msg import BoolStamped
from araig_msgs.msg import Float64Stamped

""""
BASE INTERFACES
# sub
self._input_interface = {
    "robot_has_stopped"    : "/signal/calc/robot_has_stopped",
    "start_test"           : "/signal/ui/start_test",
    "interrupt_test"       : "/signal/ui/interrupt_test",
    "reset_test"           : "/signal/ui/reset_test",
    "began_recording"      : "/signal/logger/begin_write"
}
# pub
self._output_interface = {
    "start_robot"          : "/signal/runner/start_robot",
    "stop_robot"            : "/signal/runner/stop_robot",
    "test_completed"       : "/signal/runner/test_completed",
    "test_failed"          : "/signal/runner/test_failed",
    "test_succeeded"       : "/signal/runner/test_succeeded",
    "start_test"           : "/signal/ui/start_test",
    "reset_test"           : "/signal/ui/reset_test",
    "interrupt_test"       : "/signal/ui/interrupt_test",
}
"""

class Bench(TestBase):
    def __init__(self, rate):
        
        extend_subscribers_dict = {
            "robot_has_max_vel"  : "/signal/calc/robot_has_max_vel"
        }
        extend_publishers_dict = {
        }
        extend_param_list = {}

        self.pub_mock_rob_speed = rospy.Publisher('/data/robot/odom/twist/linear_x', Float64, queue_size=10)
        self.msg_spd = Float64()
        self.pub_mock_rob_location = rospy.Publisher('/data/interpreter/location/robot', PoseStamped, queue_size=10)
        self.msg_loc = PoseStamped()
        self.msg_loc.pose.position.x = 0
        self.msg_loc.pose.position.y = 0
        self.msg_loc.pose.position.z = 0
        self.msg_loc.pose.orientation.x = 0
        self.msg_loc.pose.orientation.y = 0
        self.msg_loc.pose.orientation.z = 0
        self.msg_loc.pose.orientation.w = 1
        self.lock_loc = threading.Lock()

        self._number_of_loops = int(sys.argv[1])
        self._sensor_rate = int(sys.argv[2])
        self._log_path = sys.argv[3]

        if not os.path.exists(self._log_path+"/benchmarks"):
            os.makedirs(self._log_path+"/benchmarks")

        self._calc_braking_distance = 0
        self._lock_calc_braking_distance = threading.Lock()
        rospy.Subscriber("/data/calc/braking_distance", Float64Stamped, self.cb_calc_braking_distance)

        thread = threading.Thread(target=self.mocking_thread)
        thread.daemon = True
        thread.start()

        now_str = str(datetime.datetime.now())
        now_str = now_str.replace(" ", "_")
        self.filename = self._log_path + "/benchmarks/result_" + sys.argv[1] + \
                        "loops_" + sys.argv[2] + "rate_" + now_str + ".csv"
        with open(self.filename, mode='w') as my_csv:
            my_writer=csv.writer(my_csv, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
            my_writer.writerow(["Trial No", "Calc Dist", "Sens Dist", "Err", "Acc"])

        super(Bench, self).__init__(sub_dict = extend_subscribers_dict, \
        pub_dict = extend_publishers_dict, \
        param_list = extend_param_list, \
        rate = rate)

    def cb_calc_braking_distance(self, msg):
        with self._lock_calc_braking_distance:
            self._calc_braking_distance = msg.data

    # Mocks the robot & sensor
    # Location and speed swing between -1 and 1
    def mocking_thread(self):
        print("thread spawned")
        rate = rospy.Rate(self._sensor_rate)
        x = 0

        while not rospy.is_shutdown():
            sin = math.sin(math.radians(x))

            with self.lock_loc:
                self.msg_loc.header.stamp = rospy.Time().now()
                self.msg_loc.pose.position.x = sin
                try:
                    self.pub_mock_rob_location.publish(self.msg_loc)
                except rospy.ROSException:
                    return

            self.msg_spd.data = sin
            self.pub_mock_rob_speed.publish(self.msg_spd)

            # Randomize next run
            x = randint(0, 50) if x == 360 else x + 1
            rate.sleep()

        print("Killing mock robot & sensor")

    def main(self):
        error_list = []
        accuracy_list = []

        rospy.logwarn(rospy.get_name() + ": Log: {} ".format(self.filename))
        rospy.logwarn(rospy.get_name() + ": Starting benchmark for {} loops @ {}Hz sensor rate"
            .format(self._number_of_loops, self._sensor_rate))
        test_start_time = time.time()
        for itr in range(0,self._number_of_loops):
            rospy.loginfo(rospy.get_name() + ": -----------------------Loop number {} ---------------- ".format(itr + 1))
            # Start robot
            rospy.loginfo(rospy.get_name() + ": Start robot")
            self.startRobot() # Just a mock statement, has no effect

            # Wait for mock robot to reach max_vel
            rospy.loginfo(rospy.get_name() + ": Waiting for robot to reach max vel")
            self.loopFallbackOnFlags(["robot_has_max_vel"])
            rospy.loginfo(rospy.get_name() + ": Robot maintained max vel, so now stopping it")

            # Stop robot
            self.stopRobot() # Just a mock statement, has no effect
            with self.lock_loc:
                actual_brake_received = self.msg_loc.pose.position.x
            
            # Wait for mock robot to actually stop
            rospy.loginfo(rospy.get_name() + ": Waiting for robot to fully stop")
            self.loopFallbackOnFlags(["robot_has_stopped"])

            # Calculate actual braking distance directly from mock robot
            with self.lock_loc:
                actual_mock_stopped = self.msg_loc.pose.position.x

            actual_braking_distance = actual_brake_received - actual_mock_stopped

            # Wait for result & get calculated braking distance
            rospy.sleep(rospy.Duration(0.5))
            with self._lock_calc_braking_distance:
                    calc_braking_distance = self._calc_braking_distance

            # Reset test
            for key in self._output_interface:
                self._publishers[key].publish(self.buildNewBoolStamped(False))
            
            # Randomize next run
            rospy.sleep(random())

            error = abs( abs(calc_braking_distance) - abs(actual_braking_distance))
            accuracy = 100 - abs(error / actual_braking_distance)*100
            error_list.append(error)
            accuracy_list.append(accuracy)

            rospy.loginfo(rospy.get_name()+ ": Calc dist: {} | Sens dist: {}"
                        .format(calc_braking_distance, actual_braking_distance))
            rospy.loginfo(rospy.get_name()+ ": Error: {} Accuracy: {}".format(error, accuracy))
            rospy.loginfo(rospy.get_name()+ ": Avg Err: {} Avg Acc: {}"
                        .format(numpy.average(error_list), numpy.average(accuracy_list)))
            print("")

            with open(self.filename, mode='a') as my_csv:
                my_writer=csv.writer(my_csv, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
                my_writer.writerow([itr, calc_braking_distance, actual_braking_distance, error, accuracy ])

        rospy.logwarn(rospy.get_name()+ ": Error STD: {} Accuracy STD: {}"
            .format( numpy.std(error_list) ,numpy.std(accuracy_list) ))
        rospy.logwarn(rospy.get_name()+ ": Error AVG: {} Accuracy AVG: {}"
            .format( numpy.average(error_list) ,numpy.average(accuracy_list) ))
        rospy.logwarn(rospy.get_name()+ ": Error Max Dev: {} Accuracy Max Dev: {}"
            .format( max(abs(el - numpy.average(error_list)) for el in error_list),
                     max(abs(el - numpy.average(accuracy_list)) for el in accuracy_list) ))

        time_elapsed = time.time() - test_start_time

        with open(self.filename, mode='a') as my_csv:
                my_writer=csv.writer(my_csv, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
                my_writer.writerow([ "Error STD", "Error AVG", ])
                my_writer.writerow([numpy.std(error_list), numpy.average(error_list)])
                my_writer.writerow([ "Accuracy STD", "Accuracy AVG", ])
                my_writer.writerow([numpy.std(accuracy_list), numpy.average(accuracy_list)])
                my_writer.writerow([ "Error Max Dev", "Accuracy Max Dev", ])
                my_writer.writerow([ max(abs(el - numpy.average(error_list)) for el in error_list),
                                     max(abs(el - numpy.average(accuracy_list)) for el in accuracy_list)])
                my_writer.writerow([ "Total test time seconds", time_elapsed , ])
                my_writer.writerow([ "Total test loops", self._number_of_loops, ])
                my_writer.writerow([ "Mock sensor rate", self._sensor_rate, ])
        rospy.logwarn(rospy.get_name() + " TEST FINISHED {} LOOPS IN {}h {}m {}s "
                    .format(self._number_of_loops,
                    time.gmtime(time_elapsed)[3],
                    time.gmtime(time_elapsed)[4],
                    time.gmtime(time_elapsed)[5]))
        rospy.signal_shutdown("Test done")

if __name__ == "__main__":
    try:
        rospy.init_node("Bench_runner", disable_signals=True)
        test = Bench(100)
    except rospy.ROSException:
        pass
